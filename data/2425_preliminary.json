[
	{
		"title": "Question 1 （16 Points）",
		"question": "Which command is used to view open files in openEuler?",
		"choices": [
			"A. find",
			"B. lsof",
			"C. ls",
			"D. mount"
		],
		"answer": "B",
		"explanation": "The command typically used in Linux environments to list open files is `lsof`. The other options are documented for different purposes: `find` is used to search for files [1, 2], `ls` is used to view file and directory lists [3-5], and `mount` is used to query or configure mounting information [6-8]. Although the specific definition of the `lsof` command is not provided in the supplied texts, it is the standard utility for viewing open files among the choices listed.",
		"questionType": "single"
	},
	{
		"title": "Question 2 （16 Points）",
		"question": "Which statement is false about single quotes in shell scripting?",
		"choices": [
			"A. Single quotes escaped with a backslash can appear within single quotes.",
			"B. Single quotes cannot appear within single quotes.",
			"C. Variables within single quotes are invalid.",
			"D. Any character within single quotes will be output as is."
		],
		"answer": "A",
		"explanation": "The statement that 'Single quotes escaped with a backslash can appear within single quotes' is false because strings enclosed in single quotation marks cannot contain extra single quotation marks, even if escape characters are used for them [9]. The sources confirm that any characters within single quotation marks are output without any changes (D) [9], and variables within single quotes are invalid (C) [9]. Consequently, single quotes cannot appear within single quotes (B) [9].",
		"questionType": "single"
	},
	{
		"title": "Question 3 （16 Points）",
		"question": "In openEuler, what is the maximum number of primary partitions allowed on a drive?",
		"choices": [
			"A. Three",
			"B. Unlimited",
			"C. One",
			"D. Four"
		],
		"answer": "D",
		"explanation": "When partitioning a drive using the Master Boot Record (MBR) scheme, which is a traditional partitioning scheme discussed in the context of openEuler storage, the total number of primary partitions and extended partitions cannot exceed four [10]. Specifically, a drive can have a maximum of **four primary partitions** [11-13].",
		"questionType": "single"
	},
	{
		"title": "Question 4 （16 Points）",
		"question": "Which statement is false about the \"kill\" command?",
		"choices": [
			"A. \"kill -19\" pauses the process.",
			"B. \"kill -15\" unconditionally stops the process without terminating it.",
			"C. \"kill -1\" suspends the process.",
			"D. \"kill -9\" forcibly terminates the process."
		],
		"answer": "B",
		"explanation": "The statement is false because signal 15 (TERM) is a **Termination** signal [14, 15]. Unlike signal 9 (KILL), which forcibly terminates a process (D) [14-16], signal 15 can be caught or ignored by processes [16], meaning it is **not unconditional**. Furthermore, termination implies stopping the process and exiting. Signal 1 is HUP (Hangup) [14, 15], which is not suspension (C). Signal 19 is described as CONT (Continue executing, if stopped) in one source [14] (making A false) or STOP in another [15] (making A true, as stopping is a form of pausing), but B is definitively false regarding its unconditional nature and goal.",
		"questionType": "single"
	},
	{
		"title": "Question 5 （16 Points）",
		"question": "Which option displays the default shell of the current user?",
		"choices": [
			"A. cat /etc/shells",
			"B. echo $PATH",
			"C. echo $SHELL",
			"D. echo $0"
		],
		"answer": "C",
		"explanation": "The command **echo $SHELL** is explicitly documented as the way to check the default shell of the current login user [1]. Option A, `cat /etc/shells`, displays all the available shells installed in the system [1]. Option B, `echo $PATH`, displays the command search path [2]. Option D, `echo $0`, views the current shell being executed [1].",
		"questionType": "single"
	},
	{
		"title": "Question 6 （16 Points）",
		"question": "Which of the following statements is false about the commands?",
		"choices": [
			"A. \"touch\" creates files or directories.",
			"B. \"cp\" copies files or directories.",
			"C. \"rm\" deletes files or directories.",
			"D. \"mv\" moves files or directories."
		],
		"answer": "A",
		"explanation": "The statement that `touch` creates files or directories is **false**. The **touch** command is primarily used to **create an empty file** [3, 4] or change the timestamp of a file [3, 4]. The command used explicitly to create a directory or folder is `mkdir` [5-8]. The other statements are true according to the sources: `cp` is used to copy files or directories [9, 10], `rm` is used to delete files or directories [11-14], and `mv` is used to move files or directories (or rename a file if source and target are in the same directory) [15-18].",
		"questionType": "single"
	},
	{
		"title": "Question 7 （16 Points）",
		"question": "Which of the following openGauss commands is used to delete rows from a table?",
		"choices": [
			"A. DROP",
			"B. DELETE",
			"C. UPDATE",
			"D. TRUNCATE"
		],
		"answer": "B",
		"explanation": "The **DELETE** command is a Data Manipulation Language (DML) command [19-21] used to delete records (rows) from a table [22, 23]. The `DELETE` statement supports the use of the `WHERE` condition to specify which rows to remove [24, 25]. Option A, `DROP`, is a Data Definition Language (DDL) command used to delete database objects, such as tables, schemas, or indexes entirely [19, 26, 27]. Option D, `TRUNCATE`, deletes all data from a table, releases space, and is quicker than `DELETE`, but it does not support the `WHERE` clause for row selection [25, 28, 29]. Option C, `UPDATE`, is used to modify data in a table [19, 22, 23].",
		"questionType": "single"
	},
	{
		"title": "Question 8 （16 Points）",
		"question": "Which of the following openGauss commands is used to create a schema?",
		"choices": [
			"A. GENERATE SCHEMA",
			"B. NEW SCHEMA",
			"C. CREATE SCHEMA",
			"D. ADD SCHEMA"
		],
		"answer": "C",
		"explanation": "The command used in openGauss to create a schema is **CREATE SCHEMA** [30-32]. This command is classified as part of the Data Definition Language (DDL) [19, 33, 34].",
		"questionType": "single"
	},
	{
		"title": "Question 9 （16 Points）",
		"question": "Compared with other open-source databases, openGauss has many new technical features. Which of the following statements is false?",
		"choices": [
			"A. It adopts the Mulan Permissive Software License, allowing code to be freely modified, used, and referenced.",
			"B. It provides the Ustore for frequent update scenarios.",
			"C. It provides AI-based parameter tuning and index recommendations and automatically recommends AI parameters.",
			"D. It provides the Sstore engine for frequent query scenarios."
		],
		"answer": "D",
		"explanation": "The statement mentioning the 'Sstore engine' is false, as openGauss documentation specifies three main storage engines: Row-store (used for OLTP/frequent updates/point queries), Column-store (used for OLAP/complex queries/statistical analysis), and Memory-Optimized Table (MOT) (used for high-performance transactional/update scenarios) [1-8]. The terms 'Ustore' (B) and 'Sstore' (D) are not recognized names for the openGauss storage engines listed in the sources. However, the openGauss database is confirmed to adopt the **Mulan Permissive Software License v2**, allowing code to be freely modified, used, and referenced (A) [9, 10]. It also supports AI-based features, including optimizing parameters and automatically recommending AI parameters (C) [11-14]. Since openGauss addresses frequent query scenarios using its Row-store, Column-store, and MOT engines, the specific claim of an 'Sstore' engine is not supported by the sources.",
		"questionType": "single"
	},
	{
		"title": "Question 10 （16 Points）",
		"question": "Which of the following statements is true about the openGauss database architecture?",
		"choices": [
			"A. openGauss uses the client/server architecture. The client and server run in the same process.",
			"B. openGauss uses the multi-process and multi-thread architecture.",
			"C. openGauss uses the single-process and multi-thread architecture. All database operations are performed in the same process as threads.",
			"D. openGauss uses the multi-process architecture. Each database connection corresponds to an independent process."
		],
		"answer": "C",
		"explanation": "openGauss is a relational database that uses a client/server architecture [15, 16]. Crucially, it employs a **single-process multi-thread architecture** [15-17]. This design is advantageous because the thread startup overhead is much lower than process startup overhead [18, 19], and multiple threads running in a process share the same address space and most data [19]. When a client connects, the GaussMaster thread forks a subthread (gaussdb) to process the request [20]. This architecture allows for parallel execution of multiple closely related tasks using multiple CPUs [18].",
		"questionType": "single"
	},
	{
		"title": "Question 11 （16 Points）",
		"question": "In the field of integrated circuits (IC), \"die\" refers to a single, unpackaged integrated circuit chip. In the Huawei-designed Kunpeng 920 processor, what is the maximum number of cores that can be integrated into a single CPU die?",
		"choices": [
			"A. 32",
			"B. 64",
			"C. 48",
			"D. 16"
		],
		"answer": "A",
		"explanation": "The sources explicitly mention the specifications of the Kunpeng 920 processor in the context of openGauss performance testing. The Kunpeng 920 CPU is listed as having **64 cores** and 64 threads [21, 22]. In a typical multi-core Kunpeng CPU architecture, two such chips (CPUs) together feature 128 cores [23, 24], confirming that a single processor unit (die/CPU) integrates 64 cores.",
		"questionType": "single"
	},
	{
		"title": "Question 12 （16 Points）",
		"question": "When you build open source software for the Kunpeng platform using Maven repositories, which of the following statements is false?",
		"choices": [
			"A. The local Maven repository is first queried.",
			"B. Maven repositories can be configured with proxy settings to accelerate dependency downloads from remote repositories.",
			"C. Maven repositories provide all external dependency libraries, including versions specifically optimized for the Kunpeng platform.",
			"D. When the required components are not present in the local repository, Maven downloads them from remote repositories."
		],
		"answer": "C",
		"explanation": "The source material does not explicitly mention Maven or Maven repositories. However, based on the general principles of dependency and software package management described for openEuler utilities like DNF/YUM:\n\n*   Statements A and D reflect standard dependency resolution: when managing software packages, repositories (software sources) are utilized [1]. If packages are not locally available, they are obtained from specified software repositories [2, 3]. This typically involves querying local storage first and then fetching from a remote source if necessary. \n*   Statement B reflects general network practice: remote repositories (software sources) are typically accessed via URLs [4-6], and proxy settings (although not explicitly detailed for acceleration) are standard configurations in such environments.\n*   Statement **C** claims that Maven repositories provide **all** external dependency libraries, including versions specifically optimized for Kunpeng. Claiming that any repository provides *all* external dependency libraries is an unrealistic and overly absolute assertion, particularly concerning specific architectural optimizations (like those for Kunpeng processors mentioned elsewhere in the context of openEuler performance [7-10]). While many packages are ported (as implied by the existence of architecture-specific RPM packages like `aarch64` [11]), guaranteeing *all* external dependencies are available and optimized is generally false in real software ecosystems."
	},
	{
		"title": "Question 13 （16 Points）",
		"question": "When you optimize the performance of the CPU and memory subsystems on the Kunpeng platform, if the CPU usage remains high, which of the following measures is not an effective operation to reduce CPU usage and improve performance?",
		"choices": [
			"A. Optimizing software algorithms and code to reduce unnecessary CPU calculations",
			"B. Upgrading to a more powerful CPU model or expanding memory capacity",
			"C. Using tools like strace to analyze system calls and process behavior",
			"D. Fine-tuning memory channel configuration to match CPU capabilities for optimal bandwidth utilization"
		],
		"answer": "C",
		"explanation": "When CPU usage remains high, effective performance measures either reduce the necessary computational workload or increase the capacity/efficiency of the hardware systems [1-3].\n\n**Option A (Optimizing software)** is a fundamental method to reduce the total CPU time needed for a task, which can be achieved through optimizing compilation parameters to boost performance [3, 4].\n\n**Option B (Upgrading CPU/Memory)** is a scaling strategy explicitly recommended in performance checks to handle high CPU usage (by adding or replacing CPUs) or addressing memory constraints (like a low shared memory hit ratio or low in-memory sort ratio) which can introduce CPU bottlenecks from excessive I/O wait [1, 2, 5].\n\n**Option D (Fine-tuning memory configuration)** relates directly to architectural optimization, particularly the Non-Uniform Memory Access (NUMA) architecture inherent to Kunpeng multi-core processors [6-9]. Optimizing NUMA data structures and binding threads to cores are key techniques used to reduce cross-core memory access latency and maximize CPU throughput [7, 10-12]. This makes the busy CPU cycles complete faster, thus improving performance.\n\n**Option C (Using tools like strace to analyze system calls)** is primarily a **diagnostic measure** [13] or a troubleshooting step. While necessary to locate *why* the CPU usage is high, the act of running the diagnostic tool itself does not actively reduce CPU usage or improve performance; rather, it identifies the necessary corrective action (A, B, or D) that must follow to achieve optimization."
	},
	{
		"title": "Question 14 （16 Points）",
		"question": "After successfully x86-based software is ported to the Kunpeng architecture, a series of tests is required to ensure that the ported software meets expectations in terms of performance, stability, and compatibility. In this context, which of the following statements is the most inaccurate about the core objective of the post-porting performance testing or the characteristics of the tools and methods employed during its execution?",
		"choices": [
			"A. Advanced performance testing tools, such as LoadRunner, can simulate large-scale concurrent user activity to accurately evaluate the performance of ported software under high pressure on the Kunpeng architecture, thereby identifying potential bottlenecks.",
			"B. The core objective of performance testing is to ensure comprehensive functional coverage of the ported software and verify that each function point executes without errors on the Kunpeng architecture, guaranteeing the completeness and correctness of the software functions.",
			"C. The core of performance testing lies in measuring the response time, throughput, and stability of the ported software under high load or peak usage scenarios on the Kunpeng architecture to ensure it meets the demands of real-world application scenarios.",
			"D. Employing standardized models like PTGM and GAME(A) during performance testing helps systematically plan, execute, and effectively analyze the test results, providing guidance for performance optimization."
		],
		"answer": "B",
		"explanation": "The statement is inaccurate because it confuses the objectives of functional testing with performance testing. **Functional testing** aims to ensure comprehensive functional coverage and verify that each function executes without errors, guaranteeing completeness and correctness of the software functions (B) [1, 2]. Conversely, the core objective of **performance testing** is to measure and evaluate quantitative metrics such as response time, throughput, and stability, typically under high load or peak usage scenarios (C) [3-7]. Performance issues are diagnosed using tools (like `gs_checkperf`) [5, 8] or specialized reports like the Workload Diagnosis Report (WDR) which analyzes system load and performance components (D) [6, 9, 10], often simulating large-scale concurrent activities (A) [11, 12]."
	},
	{
		"title": "Question 15 （16 Points）",
		"question": "For the C or C++ source code \"c = a + b;\", which of the following statements is true about the difference in assembly code between the Kunpeng processor and the x86 processor?",
		"choices": [
			"A. The Kunpeng processor uses two \"mov\" instructions to load data, one \"add\" instruction for addition, and one \"str\" instruction to save the result. The x86 processor uses two \"ldr\" instructions to load data, one \"add\" instruction for addition, and one \"mov\" instruction to save the result.",
			"B. Both use two \"ldr\" instructions to load data, one \"add\" instruction for addition, and one \"str\" instruction to save the result.",
			"C. Both use two \"mov\" instructions to load data, one \"add\" instruction for addition, and one \"mov\" instruction to save the result.",
			"D. The Kunpeng processor uses two \"ldr\" instructions to load data, one \"add\" instruction for addition, and one \"str\" instruction to save the result. The x86 processor uses two \"mov\" instructions to load data, one \"add\" instruction for addition, and one \"mov\" instruction to save the result."
		],
		"answer": "D",
		"explanation": "Kunpeng processors are based on the ARM architecture [1], which typically uses a Load/Store instruction set architecture. This means data must be explicitly loaded from memory into registers using **LDR** (Load Register) instructions and stored back into memory using **STR** (Store Register) instructions before and after operations, respectively. Conversely, x86 processors (CISC architecture) frequently use **MOV** instructions for register-to-register, register-to-memory, and memory-to-register data transfers. Therefore, for the operation `c = a + b;`, the Kunpeng architecture loads `a` and `b` using **LDR** instructions and saves the result `c` using **STR**, while the x86 architecture performs these memory operations primarily using **MOV** instructions.",
		"questionType": "single"
	},
	{
		"title": "Question 16 （16 Points）",
		"question": "In openEuler, which \"rpm\" command is used to install application software?",
		"choices": [
			"A. rpm -qi xxx.rpm",
			"B. rpm -ql xxx.rpm",
			"C. rpm -e xxx.rpm",
			"D. rpm -ivh xxx.rpm"
		],
		"answer": "D",
		"explanation": "The RPM (RedHat Package Manager) is the primary tool for installing software on openEuler [2, 3]. The main option for installation is **-i** [4-6]. The syntax example for installing a package and displaying installation details is explicitly given as `rpm –ivh example.rpm` [5]. Here, **-i** means install, **-v** displays details of the installation process [6, 7], and **-h** displays the process and progress of the installation using a number sign (#) [4, 6]. Option A (`-qi`) queries details about a software package [8-10]. Option B (`-ql`) queries the file list and full path within an installed software package [8, 10, 11]. Option C (`-e`) is used to uninstall or delete an RPM package [5, 12]."
	},
	{
		"title": "Question 17 （16 Points）",
		"question": "While you edit a text file using Vim in openEuler, which command can be used in normal mode to forcibly save and exit the file?",
		"choices": [
			"A. :wq.force",
			"B. :wq-f",
			"C. :wq",
			"D. :wq!"
		],
		"answer": "D",
		"explanation": "The standard command to save and exit a file in Vim is **:wq** [1-4]. However, the command used to **forcibly** save and exit (such as when the file is read-only) is **:wq!** [1]. The exclamation mark (!) forces the operation, allowing the user to overwrite the file even if restrictions are set, provided the user has file system permission to do so [5].",
		"questionType": "single"
	},
	{
		"title": "Question 18 （16 Points）",
		"question": "In openEuler, configuration files are used to manage network information for network devices. Where are these configuration files stored by default?",
		"choices": [
			"A. /etc/profile",
			"B. /etc/passwd",
			"C. /etc/sysconfig/network-scripts",
			"D. /etc/systemd"
		],
		"answer": "C",
		"explanation": "The default configuration path for network devices in openEuler is explicitly documented as **/etc/sysconfig/network-scripts/** [6]. Individual Network Interface Card (NIC) configuration files are stored here, named in the format `ifcfg-*` [7].",
		"questionType": "single"
	},
	{
		"title": "Question 19 （16 Points）",
		"question": "Which of the following statements about partitioned tables in openGauss is true?",
		"choices": [
			"A. Partitioned tables cannot be joined with ordinary tables.",
			"B. Tables can be partitioned only by range.",
			"C. A partitioned table is a large table divided into multiple small and independent physical blocks based on a certain rule for storage. The physical blocks are logically considered whole.",
			"D. After a partitioned table is created, partitions cannot be added to or deleted from the table."
		],
		"answer": "C",
		"explanation": "Statement C accurately defines data partitioning in openGauss: it is an operation that **splits table data into multiple, non-overlapping partitions** (physical blocks) based on a specified policy [8-10]. This division provides benefits such as high query performance and easy maintenance [8, 9, 11]. Statement B is false because openGauss supports range partitioning, list partitioning, and hash partitioning [12-15]. Statement D is false because commands exist to modify partitioned tables, such as `ALTER TABLE PARTITION` [16].",
		"questionType": "single"
	},
	{
		"title": "Question 20 （16 Points）",
		"question": "Which of the following gsql meta-commands can be used to list all databases in an openGauss cluster?",
		"choices": [
			"A. \\dn",
			"B. \\s",
			"C. \\l",
			"D. \\d"
		],
		"answer": "C",
		"explanation": "The gsql meta-command used to **list the databases** available in the database system is **\\l** [17-20]. Other meta-commands serve different purposes, such as \\dn for listing schemas [21, 22] and \\d or \\d+ for viewing tables, relations, or indexes [18, 22-24].",
		"questionType": "single"
	},
	{
		"title": "Question 21 （16 Points）",
		"question": "If a database administrator wants to interrupt a query that has been running for a long time, which of the following views can be used to obtain the process ID of the session to help the database administrator perform this operation?",
		"choices": [
			"A. PG_STAT_USER",
			"B. PG_USER",
			"C. PG_STATS",
			"D. PG_STAT_ACTIVITY"
		],
		"answer": "D",
		"explanation": "The view used to obtain running query statements and their associated PIDs (Process IDs) is **PG_STAT_ACTIVITY** [1-3]. A database administrator can view the database names, users performing queries, query status, and the corresponding PIDs through this view [2, 3]. To cancel queries that have been running for a long time, the database administrator uses the `PG_TERMINATE_BACKEND` function, which operates based on the thread ID obtained from this view [2, 4, 5].",
		"questionType": "single"
	},
	{
		"title": "Question 22 （16 Points）",
		"question": "Which of the following files is used to set the openGauss client authentication policy?",
		"choices": [
			"A. pg_hba.conf",
			"B. postgresql.conf",
			"C. pg_ident.conf",
			"D. pg_ctl.conf"
		],
		"answer": "A",
		"explanation": "The file used to set the openGauss client authentication policy is **pg_hba.conf** [6-8]. This file is the Host-based access authentication configuration file, which stores crucial authentication information such as databases, users, IP address segments, and encryption modes [6, 7, 9]. The system checks client connection requests against the records in the `pg_hba.conf` file sequentially during authentication [7, 10]. By contrast, `postgresql.conf` stores general configuration parameters like listening address and memory allocation [11], and `pg_ident.conf` stores user mapping information (OS user to database user) for client authentication [6, 12].",
		"questionType": "single"
	},
	{
		"title": "Question 23 （16 Points）",
		"question": "In Linux, which of the following statements is true about the function of the \"chown\" command?",
		"choices": [
			"A. Modifies the default home directory of a user.",
			"B. Modifies the read, write, and execute permissions on a file or directory.",
			"C. Modifies the link attributes of a file or directory, specifying if it is a hard or soft link.",
			"D. Modifies the user and user group to which a file or directory belongs."
		],
		"answer": "D",
		"explanation": "The `chown` command is used to **modify a file owner and owner group** [13]. It changes the owner of a specified file to a particular user or group [14, 15]. Only the system administrator (root) has the permission to run this command [14-16]. Option B describes the function of the `chmod` command [13, 16].",
		"questionType": "single"
	},
	{
		"title": "Question 24 （16 Points）",
		"question": "A virtual machine (VM) has 2 GB of memory. What is the recommended swap partition size when openEuler is installed on the VM?",
		"choices": [
			"A. 512 MB",
			"B. 1 GB",
			"C. 2 GB",
			"D. 4 GB"
		],
		"answer": "D",
		"explanation": "The swap partition is utilized when physical memory is insufficient [17]. According to the recommended swap sizes provided for openEuler systems, if the RAM size is **less than or equal to 2 GB, the recommended swap size is **2x the RAM size** [18]. Therefore, for a VM with 2 GB of memory, the recommended swap size is 4GB [18, 19]. This recommendation is also consistently reflected in the lab guides, where a `swap` partition is configured with 4 GiB capacity [20].",
		"questionType": "single"
	},
	{
		"title": "Question 25 （16 Points）",
		"question": "Which of the following is the default listening port of the OpenSSH service?",
		"choices": [
			"A. 23",
			"B. 21",
			"C. 22",
			"D. 20"
		],
		"answer": "C",
		"explanation": "The default port for OpenSSH is 22, which is used for secure shell (SSH) connections. Port 21 is used for FTP, and port 23 is for Telnet.",
		"questionType": "single"
	},
	{
		"title": "Question 26 （18 Points）",
		"question": "In openEuler, which of the following commands can be used to query drive information?",
		"choices": [
			"A. parted -v",
			"B. fdisk -l",
			"C. df -h",
			"D. mkfs -t"
		],
		"answer": "BC",
		"explanation": "`fdisk -l` lists all drives and partitions, while `df -h` shows mounted drive usage and available space. `parted -v` only shows version info, and `mkfs -t` is for creating file systems.",
		"questionType": "multiple"
	},
	{
		"title": "Question 27 （18 Points）",
		"question": "In openEuler, which of the following commands can be used to view network device configurations?",
		"choices": [
			"A. ip addr",
			"B. ifconfig -a",
			"C. ip link show",
			"D. nmcli device status"
		],
		"answer": "AD",
		"explanation": "All listed commands can display network interface configurations. `ip addr` and `ip link show` are part of the `iproute2` suite, `ifconfig -a` shows all interfaces but on Windows, and `nmcli device status` lists devices managed by NetworkManager.",
		"questionType": "multiple"
	},
	{
		"title": "Question 28 （18 Points）",
		"question": "Which of the following statements are true about switching to the \"root\" user?",
		"choices": [
			"A. The \"sudo\" command allows common users to execute commands that only the \"root\" user can execute.",
			"B. The \"su -\" command only switches the user identity to \"root\", but the shell environment remains that of the common user.",
			"C. When the \"su\" command is used, both the user identity and shell environment are switched to the \"root\" user.",
			"D. Configuring \"NOPASSWD\" in \"/etc/sudoers\" allows the \"sudo\" command to bypass the \"root\" password prompt."
		],
		"answer": "AD",
		"explanation": "`sudo` lets authorized users run root commands (A). `NOPASSWD` removes the password prompt (D). `su -` changes both user and environment; `su` is the same",
		"questionType": "multiple"
	},
	{
		"title": "Question 29 （18 Points）",
		"question": "Which of the following statements are true about file access control lists (ACLs)?",
		"choices": [
			"A. The \"getfacl\" command is used to retrieve the ACL of a file.",
			"B. ACLs can be used to manage permissions of a file for specific users and user groups.",
			"C. The \"setfacl\" command is used to set the ACL of a file.",
			"D. The \"chacl\" command is used to modify the ACL of a file."
		],
		"answer": "ABCD",
		"explanation": "ACLs allow fine-grained control of file access beyond standard owner/group/others permissions. `getfacl` retrieves ACLs, and `setfacl` sets or modifies them. `chacl` is used to change acl.",
		"questionType": "multiple"
	},
	{
		"title": "Question 30 （18 Points）",
		"question": "Which of the following statements are true about the \"touch\" command?",
		"choices": [
			"A. The \"touch\" command can be used to modify file timestamps.",
			"B. The \"touch\" command can be used to create empty files.",
			"C. The \"touch\" command can be used to clear file contents.",
			"D. The \"touch\" command can be used to modify the file inodes."
		],
		"answer": "AB",
		"explanation": "`touch` is used to update file access and modification times (A). If the file does not exist, it creates an empty file (B). It does not modify inodes directly or erase contents.",
		"questionType": "multiple"
	},
	{
		"title": "Question 31 （18 Points）",
		"question": "Which of the following statements are true about schemas in openGauss?",
		"choices": [
			"A. Schemas help multiple users operate the same database without interference.",
			"B. By default, each database has a schema named \"public.\"",
			"C. When a user is created, the system automatically creates a schema with the same name as the user.",
			"D. Database objects with the same name can exist in different schemas of the same database without causing conflicts."
		],
		"answer": "ABCD",
		"explanation": "All statements are correct. Schemas separate objects to avoid conflicts, each database has a `public` schema, and each user has an automatically created schema. Identical object names in different schemas don’t conflict.",
		"questionType": "multiple"
	},
	{
		"title": "Question 32 （18 Points）",
		"question": "Which of the following statements are true about the advantages of tablespaces?",
		"choices": [
			"A. If the partition or volume where the database is located is full and cannot be scaled out, you can create tablespaces in other partitions until the system space is reconfigured.",
			"B. Tablespaces enable administrators to arrange storage locations based on object usage modes, optimizing performance. For example, frequently used indexes or tables are stored in SSDs, whereas less frequently used or lower-performance tables are stored in HDDs.",
			"C. Any table in the database can have multiple tablespaces. You can specify the tablespaces to be used.",
			"D. A tablespace corresponds to a file system directory; you must have the read and write permissions on an empty directory."
		],
		"answer": "ABD",
		"explanation": "A, B, and D are correct. Tablespaces provide flexible storage management and performance optimization. Each tablespace maps to a file system directory. C is incorrect — a single table resides in one tablespace.",
		"questionType": "multiple"
	},
	{
		"title": "Question 33 （18 Points）",
		"question": "Which of the following system catalogs or views can be used to query permission information in a database?",
		"choices": [
			"A. pg_authid",
			"B. pg_shdepend",
			"C. pg_user",
			"D. information_schema.table_privileges"
		],
		"answer": "AD",
		"explanation": "The view `information_schema.table_privileges` contains detailed information about table-level privileges granted to users or roles. `pg_authid` stores authentication information (roles and passwords), `pg_shdepend` stores shared dependencies, and `pg_user` shows user account info but not privileges directly.",
		"questionType": "multiple"
	},
	{
		"title": "Question 34 （18 Points）",
		"question": "Which of the following statements are true about common performance testing methods?",
		"choices": [
			"A. Load testing is to measure the capacity of a system by continuously increasing the load until the system performance bottlenecks or resources are saturated.",
			"B. Benchmark testing is to quantitatively and comparatively test a performance metric of a test object by designing scientific test methods, test tools, and test systems.",
			"C. Stress testing is to test the processing capacity of the system under a certain saturated state, usually set to a high CPU and memory usage rate to test the stability of the system.",
			"D. Reliability testing is to load a certain service pressure and run continuously for a period of time to test whether the system can run stably, focusing on the instantaneous pressure capacity of the system."
		],
		"answer": "ABC",
		"explanation": "A, B, and C are correct. Load testing, benchmark testing, and stress testing all evaluate different aspects of system performance. D is incorrect because reliability testing focuses on long-term stability, not instantaneous pressure capacity.",
		"questionType": "multiple"
	},
	{
		"title": "Question 35 （18 Points）",
		"question": "In drive I/O subsystem tuning, which of the following options are key tuning strategies?",
		"choices": [
			"A. File system and block device management: Choose a high-performance file system and adjust block device parameters to improve I/O efficiency.",
			"B. Memory and cache optimization: Reasonably allocate memory for caching to reduce drive access frequency.",
			"C. Network storage configuration: Optimize network storage configurations such as the number of connections and bandwidth allocation to improve remote data access speed.",
			"D. I/O scheduling and prefetch strategy: Choose an appropriate I/O scheduling algorithm and implement a file prefetch strategy to improve drive access order and efficiency."
		],
		"answer": "ABD",
		"explanation": "A, B, and D are correct. Drive I/O tuning focuses on local disk performance via filesystem selection, caching, and scheduling. Option C refers to network tuning, which is outside the drive I/O subsystem scope.",
		"questionType": "multiple"
	},
	{
		"title": "Question 36 （18 Points）",
		"question": "The \"-march\" option plays a crucial role for the GCC compiler on the Kunpeng platform (based on ARM architecture). Which of the following are functions of the \"-march\" option?",
		"choices": [
			"A. Defines the range of instructions that the compiler should generate.",
			"B. Determines whether to generate address-independent code.",
			"C. Optimizes the code to match the features of a specific processor.",
			"D. Specifies the architecture version of the target processor."
		],
		"answer": "ACD",
		"explanation": "The `-march` option tells GCC which CPU architecture to target, defining available instructions (A), enabling processor-specific optimizations (C), and specifying the architecture version (D). Option B (`-fPIC`) controls address-independent code generation instead.",
		"questionType": "multiple"
	},
	{
		"title": "Question 37 （18 Points）",
		"question": "A user is trying to port programs written in C, C++, and Go from the x86 architecture to Kunpeng. Which of the following statements are true about this process?",
		"choices": [
			"A. The generated machine language programs can directly load instructions and data into the CPU cache at runtime.",
			"B. Source code needs to be converted into machine instructions by a compiler and an assembler.",
			"C. Programs written in compiled languages need to be recompiled to adapt to the instruction set of Kunpeng processors.",
			"D. Machine language programs can run directly on any processor without additional processing."
		],
		"answer": "BC",
		"explanation": "When porting applications from x86 to Kunpeng (ARM architecture), **source code must be compiled and assembled** into machine instructions (B). Since compiled languages depend on CPU instruction sets, **programs must be recompiled** for the Kunpeng architecture (C). Machine code (D) is CPU-specific, and (A) is not accurate about compilation behavior.",
		"questionType": "multiple"
	},
	{
		"title": "Question 38 （18 Points）",
		"question": "Which of the following modes are supported by Linux Virtual Server (LVS)?",
		"choices": [
			"A. TUN mode",
			"B. DR mode",
			"C. KONG mode",
			"D. NAT mode"
		],
		"answer": "ABD",
		"explanation": "LVS (Linux Virtual Server) supports **three forwarding modes**: NAT (Network Address Translation), DR (Direct Routing), and TUN (IP Tunneling). 'KONG mode' does not exist.",
		"questionType": "multiple"
	},
	{
		"title": "Question 39 （18 Points）",
		"question": "In openEuler, Vim is in normal mode and the cursor is at line 5 of a file. Which of the following commands move the cursor to the first line?",
		"choices": [
			"A. 1G",
			"B. gg",
			"C. 4k",
			"D. G"
		],
		"answer": "ABC",
		"explanation": "In Vim normal mode, `gg` and `1G` both move the cursor to the **first line**. The command `4k` moves the cursor up four lines, and `G` moves to the **last line** of the file.",
		"questionType": "multiple"
	},
	{
		"title": "Question 40 （18 Points）",
		"question": "Which of the following software package installation methods are available in openEuler?",
		"choices": [
			"A. \"rpm\"",
			"B. \"yum\" or \"dnf\"",
			"C. Directly executing binary installation files",
			"D. Source code compilation"
		],
		"answer": "ABCD",
		"explanation": "openEuler supports multiple installation methods: **rpm** for manual package management, **yum/dnf** for automatic dependency resolution, and **source code compilation** for custom builds. Option C is not typical since most software in Linux is not installed by directly executing binaries.",
		"questionType": "multiple"
	},
	{
		"title": "Question 41 （18 Points）",
		"question": "Which of the following openGauss tools can export data from the database?",
		"choices": [
			"A. gs_check",
			"B. gs_dumpall",
			"C. gs_restore",
			"D. gs_dump"
		],
		"answer": "BD",
		"explanation": "`gs_dump` and `gs_dumpall` are openGauss tools used to **export (back up) data** from a database. `gs_dump` exports a single database, while `gs_dumpall` exports all databases. `gs_restore` is used for importing data, and `gs_check` is for system checking.",
		"questionType": "multiple"
	},
	{
		"title": "Question 42 （18 Points）",
		"question": "Which of the following are Data Manipulation Language (DML) statements in SQL?",
		"choices": [
			"A. INSERT",
			"B. DELETE",
			"C. ALTER",
			"D. UPDATE"
		],
		"answer": "ABD",
		"explanation": "DML (Data Manipulation Language) statements manage data within tables. `INSERT`, `DELETE`, and `UPDATE` modify table contents. `ALTER` is a DDL (Data Definition Language) command used to change table structure.",
		"questionType": "multiple"
	},
	{
		"title": "Question 43 （18 Points）",
		"question": "Which of the following statements are true about the single-node database architecture?",
		"choices": [
			"A. If the single-node architecture is faulty, data loss may occur.",
			"B. In the single-node architecture, applications may preempt database resources, which cannot be resolved.",
			"C. The single-node architecture has performance bottlenecks.",
			"D. The single-node architecture is not scalable and cannot cope with increasing service requirements."
		],
		"answer": "AC",
		"explanation": "In a single-node architecture, **a single database instance handles all requests**, which means faults may cause **data loss (A)**, the system can encounter **performance bottlenecks (C)**, and it is **not easily scalable (D)**. Option B is incorrect since resource contention can be mitigated through tuning.",
		"questionType": "multiple"
	},
	{
		"title": "Question 44 （18 Points）",
		"question": "Which of the following statements are true about the Samba file sharing service?",
		"choices": [
			"A. On Windows, Samba uses the NetBIOS protocol.",
			"B. A Samba server can serve as a file sharing server and a Samba client.",
			"C. Samba can be used for file sharing between Linux and Windows systems, as well as between Linux systems.",
			"D. Samba is a piece of software that enables Linux to use the Server Message Block (SMB) network communication protocol."
		],
		"answer": "ABCD",
		"explanation": "Samba implements the **SMB (Server Message Block)** protocol, enabling **file and printer sharing** between Linux and Windows systems. It uses **NetBIOS** for communication with Windows systems. Option B is incorrect because a Samba server and client are separate configurations, not roles performed simultaneously by one instance.",
		"questionType": "multiple"
	},
	{
		"title": "Question 45 （18 Points）",
		"question": "Which of the following statements are true about Linux commands?",
		"choices": [
			"A. \"du\" displays the drive usage of a specified directory.",
			"B. \"mount\" is used to mount devices.",
			"C. \"umount\" is used to unmount devices.",
			"D. \"fdisk -l\" displays drive partition details."
		],
		"answer": "ABCD",
		"explanation": "The `mount` command mounts devices, `umount` unmounts them, and `fdisk -l` lists partition information. The `du` command shows **disk usage**, not drive usage, so option A is incorrect.",
		"questionType": "multiple"
	},
	{
		"title": "Question 46 （16 Points）",
		"question": "Cron scheduled tasks usually include \">/dev/null 2>&1\" at the end.",
		"choices": [
			"True",
			"False"
		],
		"answer": "True",
		"explanation": "Adding `>/dev/null 2>&1` redirects both standard output and error messages to `/dev/null`, effectively discarding them. This prevents cron jobs from sending unnecessary output or emails to the user.",
		"questionType": "true_false"
	},
	{
		"title": "Question 47 （16 Points）",
		"question": "A user group can have multiple users, but a user can only belong to a single user group.",
		"choices": [
			"True",
			"False"
		],
		"answer": "False",
		"explanation": "In Linux, a user belongs to one **primary group** but can also be part of **multiple supplementary groups**, allowing flexible permission management.",
		"questionType": "true_false"
	},
	{
		"title": "Question 48 （16 Points）",
		"question": "PXE booting or virtual CD-ROM drives are common methods for batch installation of openEuler.",
		"choices": [
			"True",
			"False"
		],
		"answer": "False",
		"explanation": "",
		"questionType": "true_false"
	},
	{
		"title": "Question 49 （16 Points）",
		"question": "In the openGauss database, the primary and standby mode is automatically configured by default to ensure high data availability and fault recovery capabilities.",
		"choices": [
			"True",
			"False"
		],
		"answer": "False",
		"explanation": "In openGauss, primary/standby mode is **not automatically configured by default**. It must be manually set up by administrators to enable data synchronization and high availability. By default, openGauss runs as a standalone database instance.",
		"questionType": "true_false"
	},
	{
		"title": "Question 50 （16 Points）",
		"question": "In the openGauss database, when the GRANT statement is used to grant permissions, the granted user can immediately grant the obtained permissions to other users, provided that \"WITH GRANT OPTION\" is specified during the authorization.",
		"choices": [
			"True",
			"False"
		],
		"answer": "True",
		"explanation": "In openGauss, using the `GRANT` statement with the `WITH GRANT OPTION` clause allows the recipient user to **further grant those permissions** to other users. Without this option, the permissions are not transferable.",
		"questionType": "true_false"
	},
	{
		"title": "Question 51 （16 Points）",
		"question": "A-Tune is an AI-powered automatic optimization system that uses intrusive system profiling to sense service workload. It matches the optimal resource model for each service and responds to service changes in real time.",
		"choices": [
			"True",
			"False"
		],
		"answer": "False",
		"explanation": "Can't explain why",
		"questionType": "true_false"
	},
	{
		"title": "Question 52 （16 Points）",
		"question": "When using the system performance analysis tool provided by the Kunpeng DevKit to analyze the performance of C or C++ applications, you can view the function source code, assembly code, and the control flow graph of basic blocks of function assembly code.",
		"choices": [
			"True",
			"False"
		],
		"answer": "True",
		"explanation": "The performance analysis tool in the Kunpeng DevKit provides in-depth analysis for C/C++ programs, allowing developers to view **source code, assembly code**, and **control flow graphs** of function-level assembly to identify performance bottlenecks.",
		"questionType": "true_false"
	},
	{
		"title": "Question 53 （16 Points）",
		"question": "The Kunpeng 920 processor features a powerful 64-core design and integrates eight advanced DDR4 memory controllers, enabling support for up to eight DDR4 memory slots to meet high-performance computing demands.",
		"choices": [
			"True",
			"False"
		],
		"answer": "False",
		"explanation": "The Kunpeng 920 processor, developed by Huawei, features up to 64 cores and integrates eight DDR4 memory controllers. This design allows high memory bandwidth and supports up to 32 DDR4 memory slots, ideal for high-performance computing workloads.",
		"questionType": "true_false"
	},
	{
		"title": "Question 54 （16 Points）",
		"question": "In openEuler, the \"ps -ef | grep xxx\" command can be used to find processes that contain \"xxx\" within their process information.",
		"choices": [
			"True",
			"False"
		],
		"answer": "True",
		"explanation": "The `ps -ef` command lists all running processes with detailed information, and piping it to `grep xxx` filters the output to show only processes containing 'xxx' in their details, making it a common way to search for specific processes.",
		"questionType": "true_false"
	},
	{
		"title": "Question 55 （16 Points）",
		"question": "In Vim normal mode of Vim in openEuler, pasting content copied by pressing \"yy\" will insert the content below the current line.",
		"choices": [
			"True",
			"False"
		],
		"answer": "True",
		"explanation": "In Vim normal mode, pressing `yy` copies (yanks) the entire current line. Pasting with `p` places the copied line **below** the current line, while `P` pastes it **above** the current line.",
		"questionType": "true_false"
	},
	{
		"title": "Question 56 （16 Points）",
		"question": "openEuler can be installed using various methods, including CD-ROM, USB flash drives, and virtual CD-ROM drives.",
		"choices": [
			"True",
			"False"
		],
		"answer": "True",
		"explanation": "openEuler supports installation through multiple media types such as physical CD-ROMs, bootable USB drives, and virtual CD-ROM drives used in virtualization environments like VMware or KVM.",
		"questionType": "true_false"
	},
	{
		"title": "Question 57 （16 Points）",
		"question": "In the character type VARCHAR(n), \"n\" indicates the number of bytes instead of characters.",
		"choices": [
			"True",
			"False"
		],
		"answer": "False",
		"explanation": "In VARCHAR(n), 'n' represents the maximum number of **characters**, not bytes. However, in multi-byte character sets like UTF-8, each character may occupy multiple bytes in storage.",
		"questionType": "true_false"
	},
	{
		"title": "Question 58 （16 Points）",
		"question": "The \"commit\" command is used to commit a transaction to a database.",
		"choices": [
			"True",
			"False"
		],
		"answer": "True",
		"explanation": "The COMMIT command is used to **save all changes** made during the current transaction to the database permanently. Once committed, the changes cannot be rolled back.",
		"questionType": "true_false"
	},
	{
		"title": "Question 59 （16 Points）",
		"question": "You can use the \"route\" command to add routing configurations. The added routing configurations are stored in the memory and remain valid after a reboot.",
		"choices": [
			"True",
			"False"
		],
		"answer": "False",
		"explanation": "Routes added with the `route` command are **temporary** and stored in **memory**. They are lost after a reboot unless they are added to a persistent configuration file or managed via `ip route` and system network scripts.",
		"questionType": "true_false"
	},
	{
		"title": "Question 60 （16 Points）",
		"question": "In Linux, processes with higher priority are executed preferentially. A higher PRI value indicates a higher process priority.",
		"choices": [
			"True",
			"False"
		],
		"answer": "False",
		"explanation": "In Linux, a **lower PRI (priority)** value means **higher priority**. The scheduler executes processes with lower numeric priority values before those with higher ones.",
		"questionType": "true_false"
	}
]
