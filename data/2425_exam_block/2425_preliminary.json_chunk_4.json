[
  {
    "title": "Question 13 （16 Points）",
    "question": "When you optimize the performance of the CPU and memory subsystems on the Kunpeng platform, if the CPU usage remains high, which of the following measures is not an effective operation to reduce CPU usage and improve performance?",
    "choices": [
      "A. Optimizing software algorithms and code to reduce unnecessary CPU calculations",
      "B. Upgrading to a more powerful CPU model or expanding memory capacity",
      "C. Using tools like strace to analyze system calls and process behavior",
      "D. Fine-tuning memory channel configuration to match CPU capabilities for optimal bandwidth utilization"
    ],
    "answer": "C",
    "explanation": "When CPU usage remains high, effective performance measures either reduce the necessary computational workload or increase the capacity/efficiency of the hardware systems [1-3].\n\n**Option A (Optimizing software)** is a fundamental method to reduce the total CPU time needed for a task, which can be achieved through optimizing compilation parameters to boost performance [3, 4].\n\n**Option B (Upgrading CPU/Memory)** is a scaling strategy explicitly recommended in performance checks to handle high CPU usage (by adding or replacing CPUs) or addressing memory constraints (like a low shared memory hit ratio or low in-memory sort ratio) which can introduce CPU bottlenecks from excessive I/O wait [1, 2, 5].\n\n**Option D (Fine-tuning memory configuration)** relates directly to architectural optimization, particularly the Non-Uniform Memory Access (NUMA) architecture inherent to Kunpeng multi-core processors [6-9]. Optimizing NUMA data structures and binding threads to cores are key techniques used to reduce cross-core memory access latency and maximize CPU throughput [7, 10-12]. This makes the busy CPU cycles complete faster, thus improving performance.\n\n**Option C (Using tools like strace to analyze system calls)** is primarily a **diagnostic measure** [13] or a troubleshooting step. While necessary to locate *why* the CPU usage is high, the act of running the diagnostic tool itself does not actively reduce CPU usage or improve performance; rather, it identifies the necessary corrective action (A, B, or D) that must follow to achieve optimization."
  },
  {
    "title": "Question 14 （16 Points）",
    "question": "After successfully x86-based software is ported to the Kunpeng architecture, a series of tests is required to ensure that the ported software meets expectations in terms of performance, stability, and compatibility. In this context, which of the following statements is the most inaccurate about the core objective of the post-porting performance testing or the characteristics of the tools and methods employed during its execution?",
    "choices": [
      "A. Advanced performance testing tools, such as LoadRunner, can simulate large-scale concurrent user activity to accurately evaluate the performance of ported software under high pressure on the Kunpeng architecture, thereby identifying potential bottlenecks.",
      "B. The core objective of performance testing is to ensure comprehensive functional coverage of the ported software and verify that each function point executes without errors on the Kunpeng architecture, guaranteeing the completeness and correctness of the software functions.",
      "C. The core of performance testing lies in measuring the response time, throughput, and stability of the ported software under high load or peak usage scenarios on the Kunpeng architecture to ensure it meets the demands of real-world application scenarios.",
      "D. Employing standardized models like PTGM and GAME(A) during performance testing helps systematically plan, execute, and effectively analyze the test results, providing guidance for performance optimization."
    ],
    "answer": "B",
    "explanation": "The statement is inaccurate because it confuses the objectives of functional testing with performance testing. **Functional testing** aims to ensure comprehensive functional coverage and verify that each function executes without errors, guaranteeing completeness and correctness of the software functions (B) [1, 2]. Conversely, the core objective of **performance testing** is to measure and evaluate quantitative metrics such as response time, throughput, and stability, typically under high load or peak usage scenarios (C) [3-7]. Performance issues are diagnosed using tools (like `gs_checkperf`) [5, 8] or specialized reports like the Workload Diagnosis Report (WDR) which analyzes system load and performance components (D) [6, 9, 10], often simulating large-scale concurrent activities (A) [11, 12]."
  },
  {
    "title": "Question 15 （16 Points）",
    "question": "For the C or C++ source code \"c = a + b;\", which of the following statements is true about the difference in assembly code between the Kunpeng processor and the x86 processor?",
    "choices": [
      "A. The Kunpeng processor uses two \"mov\" instructions to load data, one \"add\" instruction for addition, and one \"str\" instruction to save the result. The x86 processor uses two \"ldr\" instructions to load data, one \"add\" instruction for addition, and one \"mov\" instruction to save the result.",
      "B. Both use two \"ldr\" instructions to load data, one \"add\" instruction for addition, and one \"str\" instruction to save the result.",
      "C. Both use two \"mov\" instructions to load data, one \"add\" instruction for addition, and one \"mov\" instruction to save the result.",
      "D. The Kunpeng processor uses two \"ldr\" instructions to load data, one \"add\" instruction for addition, and one \"str\" instruction to save the result. The x86 processor uses two \"mov\" instructions to load data, one \"add\" instruction for addition, and one \"mov\" instruction to save the result."
    ],
    "answer": "D",
    "explanation": "Kunpeng processors are based on the ARM architecture [1], which typically uses a Load/Store instruction set architecture. This means data must be explicitly loaded from memory into registers using **LDR** (Load Register) instructions and stored back into memory using **STR** (Store Register) instructions before and after operations, respectively. Conversely, x86 processors (CISC architecture) frequently use **MOV** instructions for register-to-register, register-to-memory, and memory-to-register data transfers. Therefore, for the operation `c = a + b;`, the Kunpeng architecture loads `a` and `b` using **LDR** instructions and saves the result `c` using **STR**, while the x86 architecture performs these memory operations primarily using **MOV** instructions.",
    "questionType": "single"
  },
  {
    "title": "Question 16 （16 Points）",
    "question": "In openEuler, which \"rpm\" command is used to install application software?",
    "choices": [
      "A. rpm -qi xxx.rpm",
      "B. rpm -ql xxx.rpm",
      "C. rpm -e xxx.rpm",
      "D. rpm -ivh xxx.rpm"
    ],
    "answer": "D",
    "explanation": "The RPM (RedHat Package Manager) is the primary tool for installing software on openEuler [2, 3]. The main option for installation is **-i** [4-6]. The syntax example for installing a package and displaying installation details is explicitly given as `rpm –ivh example.rpm` [5]. Here, **-i** means install, **-v** displays details of the installation process [6, 7], and **-h** displays the process and progress of the installation using a number sign (#) [4, 6]. Option A (`-qi`) queries details about a software package [8-10]. Option B (`-ql`) queries the file list and full path within an installed software package [8, 10, 11]. Option C (`-e`) is used to uninstall or delete an RPM package [5, 12]."
  }
]